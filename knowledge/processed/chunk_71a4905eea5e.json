{
  "id": "71a4905eea5e",
  "source": "Quantitative_Trading.pdf",
  "source_type": "pdf",
  "title": "Quantitative Trading",
  "chunk_index": 17,
  "content": "of comparison, you can find my list saved as epchan.com/book/SP500_20071121.xls. The easiest way to download historical data for all these stocks is to modify example3_1.m, example3_1.py, or example3_1.R, and save only the Date and Close fields for each stock symbol, into a file SPX_20071123.txt (downloadable from epchan.com/book). Next, we can use this historical data set to backtest the mean-revert- ing strategy without transaction cost: Using MATLAB clear; startDate=20060101; endDate=20061231; T=readtable('SPX_20071123.txt'); tday=T{:, 1}; cl=T{:, 2:end}; % daily returns dailyret=(cl-lag1(cl))./lag1(cl); % equal weighted market index return marketDailyret=smartmean(dailyret, 2); % weight of a stock is proportional to the negative % distance to the market index. weights=... Chan800064_c03.indd 73 6/7/2021 2:04:51 PM 34 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. 74 QUANTITATIVE TRADING -(dailyret-repmat(marketDailyret,[1 size(dailyret,2)]))./ repmat(smartsum(isfinite(cl), 2), ... [1 size(dailyret, 2)]); % those stocks that do not have valid prices or % daily returns are excluded. weights(~isfinite(cl) | ~isfinite(lag1(cl)))=0; dailypnl=smartsum(lag1(weights).*dailyret, 2); % remove pnl outside of our dates of interest dailypnl(tday < startDate | tday > endDate) = []; % Sharpe ratio should be about 0.25 sharpe=... sqrt(252)*smartmean(dailypnl, 1)/smartstd(dailypnl, 1) This file was saved as epchan.com/book/example3_7.m on my web- site. Notice that the Sharpe ratio in 2006 is only 0.25, not 4.47 as stated by the original authors. The reason for this drastically lower performance is due to the use of the large market capitalization universe of S&P 500 in our backtest. If you read the original paper by the authors, you will find that most of the returns are generated by small and microcap stocks. In this MATLAB program, I have used three new functions: \u201csmart- sum,\u201d \u201csmartmean,\u201d and \u201csmartstd.\u201d They are very similar to the usual \u201csum,\u201d \u201cmean,\u201d and \u201cstd\u201d functions, except they skip all the NaN entries in the data. These functions are very useful in backtesting because a price series for stocks often starts and stops. These files are all available at epchan.com/book. function y = smartsum(x, dim) %y = smartsum(x, dim) %Sum along dimension dim, ignoring NaN. hasData=isfinite(x); x(~hasData)=0; y=sum(x,dim); y(all(~hasData, dim))=NaN; \"martmean.m\" function y = smartmean(x, dim) % y = smartmean(x, dim) % Mean value along dimension dim, ignoring NaN. hasData=isfinite(x); x(~hasData)=0; y=sum(x,dim)./sum(hasData, dim); y(all(~hasData, dim))=NaN; % set y to NaN if all entries are NaNs. \"smartstd.m\" function y = smartstd(x, dim) %y = smartstd(x, dim) % std along dimension dim, ignoring NaN and Inf Chan800064_c03.indd 74 6/7/2021 2:04:51 PM 35 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Backtesting 75 hasData=isfinite(x); x(~hasData)=0; y=std(x); y(all(~hasData, dim))=NaN; Now, continuing with our backtest, let\u2019s see what happens if we deduct a 5-basis-point transaction cost for every trade. % daily pnl with transaction costs deducted onewaytcost=0.0005; % assume 5 basis points % remove weights outside of our dates of interest weights(tday < startDate | tday > endDate, :) = []; % transaction costs are only incurred when % the weights change dailypnlminustcost=... dailypnl - smartsum(abs(weights-lag1(weights)), 2).* onewaytcost; % Sharpe ratio should be about -3.19 sharpeminustcost=... sqrt(252)*smartmean(dailypnlminustcost, 1)/... smartstd(dailypnlminustcost, 1) The strategy is now very unprofitable! Using Python This file was saved as epchan.com/book/example3_7.ipynb Simple Mean-Reverting Model with and without Transaction Costs import numpy as np import pandas as pd startDate=20060101 endDate=20061231 df=pd.read_table('SPX_20071123.txt') df['Date']=df['Date'].astype('int') df.set_index('Date', inplace=True) df.sort_index(inplace=True) dailyret=df.pct_change() marketDailyret=dailyret.mean(axis=1) weights=-(np.array(dailyret)-np.array(marketDailyret). reshape((dailyret.shape[0], 1))) wtsum=np.nansum(abs(weights), axis=1) weights[wtsum==0,]=0 wtsum[wtsum==0]=1 weights=weights/wtsum.reshape((dailyret.shape[0],1)) dailypnl=np.nansum(np.array(pd.DataFrame(weights). shift())*np.array(dailyret), axis=1) Chan800064_c03.indd 75 6/7/2021 2:04:51 PM 36 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. 76 QUANTITATIVE TRADING dailypnl=dailypnl[np.logical_and(df.index >= startDate, df.index <= endDate)] sharpeRatio=np.sqrt(252)*np.mean(dailypnl)/ np.std(dailypnl) sharpeRatio 0.957785681010386 With transaction costs onewaytcost=0.0005 weights=weights[np.logical_and(df.index >= startDate, df.index <= endDate)] dailypnlminustcost=dailypnl - (np.nansum(abs(weights- np.array(pd.DataFrame(weights).shift())), axis=1)*onewaytcost) sharpeRatioMinusTcost=np.sqrt(252)*np. mean(dailypnlminustcost)/np.std(dailypnlminustcost) sharpeRatioMinusTcost -2.1617433718962276 Using R This file was saved as epchan.com/book/example3_7.R. library('zoo') source('calculateReturns.R') source('calculateMaxDD.R') source('backshift.R') startDate <- 20060101 endDate <- 20061231 data1 <- read.delim(\"SPX_20071123.txt\") # Tab-delimited cl <- data.matrix(data1[, 2:ncol(data1)]) tday <- data.matrix(data1[, 1]) dailyret <- calculateReturns(cl, 1) marketDailyret <- rowMeans(dailyret, na.rm = TRUE) # First few entries should be c(NaN, -0.001131229, -0.010251817, -0.000813797, ...) weights <- -(dailyret - marketDailyret) weights <- weights/rowSums(abs(weights), na.rm = TRUE) pnl <- rowSums(backshift(1, weights)*dailyret, na.rm = TRUE) testset <- which(tday >= startDate & tday <= endDate) sharpeRatioTestset <- sqrt(252)*mean(pnl[testset], na.rm = TRUE)/sd(pnl[testset], na.rm = TRUE) sharpeRatioTestset # 0.4170207 # With transaction costs onewaytcost <- 5/10000 # 5 bps Chan800064_c03.indd 76 6/7/2021 2:04:51 PM 37 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Backtesting 77 STRATEGY REFINEMENT If a strategy does not deliver superb backtest performance on first trial, there are some common ways to improve it. How to refine a strategy without introducing data-snooping bias and to remain simple with few parameters is more of an art than a science. The guiding principle is the same as that of parameter optimization: Whatever changes you make to the strategy to improve its perfor - mance on the training set, it must also improve the performance on the test set. Often, there are some very simple strategies that are fairly well known in traders\u2019 circles and are still somewhat profitable, though their returns seem to be diminishing. An example is",
  "word_count": 1000,
  "topics": [
    "options",
    "psychology",
    "strategies"
  ],
  "created_at": "2026-02-05T00:37:43.606368"
}