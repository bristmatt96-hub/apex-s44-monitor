{
  "id": "ad6b6a2f369d",
  "source": "Quantitative_Trading.pdf",
  "source_type": "pdf",
  "title": "Quantitative Trading",
  "chunk_index": 15,
  "content": "spread=df.loc[:, 'Adj Close_GLD']-hedgeRatio[0]*df. loc[:, 'Adj Close_GDX'] plt.plot(spread.iloc[trainset]) plt.plot(spread.iloc[testset]) spreadMean=np.mean(spread.iloc[trainset]) spreadMean 0.05219623850035999 spreadStd=np.std(spread.iloc[trainset]) spreadStd 1.944860873496509 df['zscore']=(spread-spreadMean)/spreadStd df['positions_GLD_Long']=0 df['positions_GDX_Long']=0 df['positions_GLD_Short']=0 df['positions_GDX_Short']=0 df.loc[df.zscore>=2, ('positions_GLD_Short', 'positions_ GDX_Short')]=[-1, 1] # Short spread df.loc[df.zscore<=-2, ('positions_GLD_Long', 'positions_ GDX_Long')]=[1, -1] # Buy spread df.loc[df.zscore<=1, ('positions_GLD_Short', 'positions_ GDX_Short')]=0 # Exit short spread Chan800064_c03.indd 68 6/7/2021 2:04:51 PM 30 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Backtesting 69 df.loc[df.zscore>=-1, ('positions_GLD_Long', 'positions_ GDX_Long')]=0 # Exit long spread df.fillna(method='ffill', inplace=True) # ensure exist- ing positions are carried forward unless there is an exit signal positions_Long=df.loc[:, ('positions_GLD_Long', 'posi- tions_GDX_Long')] positions_Short=df.loc[:, ('positions_GLD_Short', 'posi- tions_GDX_Short')] positions=np.array(positions_Long)+np.array(positions_ Short) positions=pd.DataFrame(positions) dailyret=df.loc[:, ('Adj Close_GLD', 'Adj Close_GDX')]. pct_change() pnl=(np.array(positions.shift())*np.array(dailyret)).sum (axis=1) sharpeTrainset=np.sqrt(252)*np.mean(pnl[trainset[1:]])/ np.std(pnl[trainset[1:]]) sharpeTrainset 1.9182982282569077 sharpeTestset=np.sqrt(252)*np.mean(pnl[testset])/ np.std(pnl[testset]) sharpeTestset 1.494313761833427 plt.plot(np.cumsum(pnl[testset])) positions.to_pickle('example3_6_positions') Using R You can download the R code as example3_6.R. library('zoo') source('calculateReturns.R') source('calculateMaxDD.R') source('backshift.R') data1 <- read.delim(\"GLD.txt\") # Tab-delimited data_sort1 <- data1[order(as.Date(data1[,1], '%m/%d/%Y')),] # sort in ascending order of dates (1st column of data) tday1 <- as.integer(format(as.Date(data_sort1[,1], '%m/%d/%Y'), '%Y%m%d')) adjcls1 <- data_sort1[,ncol(data_sort1)] data2 <- read.delim(\"GDX.txt\") # Tab-delimited data_sort2 <- data2[order(as.Date(data2[,1], '%m/%d/%Y')),] # sort in ascending order of dates (1st column of data) Chan800064_c03.indd 69 6/7/2021 2:04:51 PM 31 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. 70 QUANTITATIVE TRADING tday2 <- as.integer(format(as.Date(data_sort2[,1], '%m/%d/%Y'), '%Y%m%d')) adjcls2 <- data_sort2[,ncol(data_sort2)] # find the intersection of the two data sets tday <- intersect(tday1, tday2) adjcls1 <- adjcls1[tday1 %in% tday] adjcls2 <- adjcls2[tday2 %in% tday] # define indices for training and test sets trainset <- 1:252 testset <- length(trainset)+1:length(tday) # determines the hedge ratio on the trainset result <- lm(adjcls1 ~ 0 + adjcls2, subset=trainset ) hedgeRatio <- coef(result) # 1.631 spread <- adjcls1-hedgeRatio*adjcls2 # spread = GLD - hedgeRatio*GDX plot(spread) dev.new() plot(spread[trainset]) dev.new() plot(spread[testset]) # mean of spread on trainset spreadMean <- mean(spread[trainset]) # 0.05219624 # standard deviation of spread on trainset spreadStd <- sd(spread[trainset]) # 1.948731 zscore <- (spread-spreadMean)/spreadStd longs <- zscore <= -2 # buy spread when its value drops below 2 standard deviations. shorts <- zscore >= 2 # short spread when its value rises above 2 standard deviations. # exit any spread position when its value is within 1 standard deviation of its mean. longExits <- zscore >= -1 shortExits <- zscore <= 1 posL <- matrix(NaN, length(tday), 2) # long positions posS <- matrix(NaN, length(tday), 2) # short positions # initialize to 0 posL[1,] <- 0 posS[1,] <- 0 posL[longs, 1] <- 1 posL[longs, 2] <- -1 posS[shorts, 1] <- -1 posS[shorts, 2] <- 1 posL[longExits, 1] <- 0 posL[longExits, 2] <- 0 posS[shortExits, 1] <- 0 Chan800064_c03.indd 70 6/7/2021 2:04:51 PM 32 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Backtesting 71 Sensitivity Analysis Once you have optimized your parameters as well as various features of your model and have verified that its performance on a test set is still reasonable, vary these parameters or make some small qualitative changes in the features of the model and see how the performance changes on both the training and the test sets. If the drop is so drastic that any parameter set other than the optimal one is unacceptable, the model most likely suffers from data-snooping bias. There are some variations on your model that are particularly important to try: the various ways to simplify the model. Do you really need, say, five different conditions to determine whether to make that trade? What if you eliminate the conditions one by one\u2014 at what point does the performance on the training set deteriorate to an unacceptable level? And more important: Is there a correspond- ing decrease in performance on the test set as you eliminate the conditions? In general, you should eliminate as many conditions, posS[shortExits, 2] <- 0 # ensure existing positions are carried forward unless there is an exit signal posL <- zoo::na.locf(posL) posS <- zoo::na.locf(posS) positions <- posL + posS cl <- cbind(adjcls1, adjcls2) # last row is [385,] 77.32 46.36 # daily returns of price series dailyret <- calculateReturns(cl, 1) # last row is [385,] -0.0122636689 -0.0140365802 pnl <- rowSums(backshift(1, positions)*dailyret) sharpeRatioTrainset <- sqrt(252)*mean(pnl[trainset], na.rm = TRUE)/sd(pnl[trainset], na.rm = TRUE) sharpeRatioTrainset # 2.327844 sharpeRatioTestset <- sqrt(252)*mean(pnl[testset], na.rm = TRUE)/sd(pnl[testset], na.rm = TRUE) sharpeRatioTestset # 1.508212 This codes makes use of the function backshift, which you can download as backshift.R. backshift <- function(mylag, x) { rbind(matrix(NaN, mylag, ncol(x)), as.matrix(x[1:(nrow(x)-mylag),])) } Chan800064_c03.indd 71 6/7/2021 2:04:51 PM 72 QUANTITATIVE TRADING constraints, and parameters as possible as long as there is no sig- nificant decrease in performance in the test set, even though it may decrease performance on the training set. (But you should not add conditions and parameters, or adjust the parameter values, so as to improve performance on the test set: If you do, you have effectively used the test set as your training set and possibly reintroduced data- snooping bias to your model.) When one has reduced the set of parameters and conditions that trigger a trade to the minimum, and after one has ascertained that small variations in these parameters and conditions do not drasti- cally alter the out-of-sample performance, one should consider dividing the trading capital across the different parameter values and sets of conditions. This averaging over parameters will further help ensure that the actual trading performance of the model will not deviate too much",
  "word_count": 1000,
  "topics": [
    "options",
    "psychology",
    "market_structure",
    "strategies",
    "crypto",
    "forex"
  ],
  "created_at": "2026-02-05T00:37:43.605977"
}