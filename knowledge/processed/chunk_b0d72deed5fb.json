{
  "id": "b0d72deed5fb",
  "source": "Quantitative_Trading.pdf",
  "source_type": "pdf",
  "title": "Quantitative Trading",
  "chunk_index": 13,
  "content": "<- function(cumret) { # Assume compounded cumulative return as input highwatermark <- rep(0, length(cumret)) highwatermark drawdown <- rep(0, length(cumret)) drawdownduration <- rep(0, length(cumret)) for (t in 2:length(cumret)) { highwatermark[t] <- max(highwatermark[t-1], cumret[t]) drawdown[t] <- (1+cumret[t])/(1+highwatermark[t])-1 if (drawdown[t]==0) { drawdownduration[t]=0 } else { drawdownduration[t]=drawdownduration[t-1]+1 } } maxDD <- min(drawdown) maxDDD <- max(drawdownduration) return(c(maxDD, maxDDD)) } Then you can run the following code, which is the third part of example3_4.R: # 3rd part of example 3.4 source('calculateMaxDD.R') cumret <- cumprod(1+excessRet[!is.nan(excessRet)])-1 plot(cumret) output <- calculateMaxDD(cumret) maxDD <- output[1] maxDD maxDDD <- output[2] maxDDD Chan800064_c03.indd 57 6/7/2021 2:04:50 PM 24 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Backtesting 57 COMMON BACKTESTING PITFALLS TO AVOID Backtesting is the process of creating the historical trades given the historical information available at that time, and then finding out what the subsequent performance of those trades is. This process Using R You first need to download the function calculateMaxDD.R to your folder. # calculateMaxDD.R calculateMaxDD <- function(cumret) { # Assume compounded cumulative return as input highwatermark <- rep(0, length(cumret)) highwatermark drawdown <- rep(0, length(cumret)) drawdownduration <- rep(0, length(cumret)) for (t in 2:length(cumret)) { highwatermark[t] <- max(highwatermark[t-1], cumret[t]) drawdown[t] <- (1+cumret[t])/(1+highwatermark[t])-1 if (drawdown[t]==0) { drawdownduration[t]=0 } else { drawdownduration[t]=drawdownduration[t-1]+1 } } maxDD <- min(drawdown) maxDDD <- max(drawdownduration) return(c(maxDD, maxDDD)) } Then you can run the following code, which is the third part of example3_4.R: # 3rd part of example 3.4 source('calculateMaxDD.R') cumret <- cumprod(1+excessRet[!is.nan(excessRet)])-1 plot(cumret) output <- calculateMaxDD(cumret) maxDD <- output[1] maxDD maxDDD <- output[2] maxDDD Chan800064_c03.indd 57 6/7/2021 2:04:50 PM Backtesting 63 results are correct, then the entire period between the time of pub- lication and the time that you tested the strategy is a genuine out-of- sample period. As long as you do not optimize the parameters of the published model on the out-of-sample period, this period is as good as paper trading the strategy. Example 3.6: Pair Trading of GLD and GDX This example will illustrate how to separate the data into a training set and a test set. We will backtest a pair-trading strategy and optimize its param- eters on the training set and look at the effect on the test set. GLD versus GDX is a good candidate for pair trading because GLD reflects the spot price of gold, and GDX is a basket of gold-mining stocks. It makes intuitive sense that their prices should move in tandem. I have discussed this pair of ETFs extensively on my blog in connection with coin- tegration analysis (see, e.g., Chan, 2006b). Here, however, I will defer until Chapter 7 the cointegration analysis on the training set, which demon- strates that the spread formed by long GLD and short GDX is mean revert- ing. Instead, we will perform a regression analysis on the training set to determine the hedge ratio between GLD and GDX, and then define entry and exit thresholds for a pair-trading strategy. We will see how optimizing these thresholds on the training set changes the performance on the test set. (This program is available as on epchan.com/book/example3_6.m. The data files are available as GDX.xls and GLD.xls. This program uses a lag1 function, which will lag the time series by one time period. It is included at epchan.com/book as well. It also uses a function \u201cols\u201d for lin- ear regression, which is part of a free package downloaded from spatial- econometrics.com.) Using MATLAB clear; % make sure previously defined variables are erased. [num, txt]=xlsread('GLD'); % read a spreadsheet named \"GLD.xls\" into MATLAB. tday1=txt(2:end, 1); % the first column (starting from the second row) is the trading days in format mm/dd/ yyyy. tday1=datestr(datenum(tday1, 'mm/dd/yyyy'), 'yyyymmdd'); % convert the format into yyyymmdd 20041118-20071130. Chan800064_c03.indd 63 6/7/2021 2:04:50 PM 25 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. 64 QUANTITATIVE TRADING tday1=str2double(cellstr(tday1)); % convert the date strings first into cell arrays and then into numeric format. adjcls1=num(:, end); % the last column contains the adjusted close prices. [num, txt]=xlsread('GDX'); % read a spreadsheet named \"GDX.xls\" into MATLAB. tday2=txt(2:end, 1); % the first column (starting from the second row) is the trading days in format mm/dd/ yyyy. tday2=datestr(datenum(tday2, 'mm/dd/yyyy'), 'yyyymmdd'); % convert the format into yyyymmdd 20060523-20071130. tday2=str2double(cellstr(tday2)); % convert the date strings first into cell arrays and then into numeric format. adjcls2=num(:, end); % the last column contains the adjusted close prices. [tday, idx1, idx2]=intersect(tday1, tday2); % find the intersection of the two data sets, and sort them in ascending order cl1=adjcls1(idx1); cl2=adjcls2(idx2); trainset=1:252; % define indices for training set testset=trainset(end)+1:length(tday); % define indices for test set % determines the hedge ratio on the trainset results=ols(cl1(trainset), cl2(trainset)); % use regres- sion function hedgeRatio=results.beta; % 1.6368 spread=cl1-hedgeRatio*cl2; % spread = GLD - hedgeRatio*GDX plot(spread(trainset)); Chan800064_c03.indd 64 6/7/2021 2:04:51 PM 26 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Backtesting 65 figure; plot(spread(testset)); figure; spreadMean=mean(spread(trainset)); % mean of spread on trainset spreadStd=std(spread(trainset)); % standard deviation of spread on trainset zscore=(spread - spreadMean)./spreadStd; % z-score of spread longs=zscore<=-2; % buy spread when its value drops below 2 standard deviations. shorts=zscore>=2; % short spread when its value rises above 2 standard deviations. exitLongs=zscore>=-1; % exit any spread position when its value is within 1 standard deviation of its mean. exitShorts=zscore<=1; % exit any",
  "word_count": 1000,
  "topics": [
    "options",
    "risk_management",
    "market_structure",
    "strategies",
    "crypto",
    "forex"
  ],
  "created_at": "2026-02-05T00:37:43.605566"
}