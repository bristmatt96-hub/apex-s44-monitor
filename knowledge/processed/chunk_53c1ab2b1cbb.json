{
  "id": "53c1ab2b1cbb",
  "source": "Quantitative_Trading.pdf",
  "source_type": "pdf",
  "title": "Quantitative Trading",
  "chunk_index": 43,
  "content": "AM 92 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Special Topics in Quantitative Trading 177 function assert(pred, str) % ASSERT Raise an error if the predicate is not true. % assert(pred, string) if nargin<2, str = ''; end if ~pred s = sprintf('assertion violated: %s', str); error(s); end The second one is the fwdshift function, which works in the opposite way to the lag1 function: It shifts the time series one step forward. function y=fwdshift(day,x) assert(day>=0); y=[x(day+1:end,:,:); .. NaN*ones(day,size(x,2), size(x, 3))]; Using Python The Python codes can be found at epchan.com/book/example7_6.py, and the input data is also available there. # Backtesting the January Effect import numpy as np import pandas as pd onewaytcost=0.0005 df=pd.read_table('IJR_20080131.txt') df['Date']=df['Date'].round().astype('int') df['Date']=pd.to_datetime(df['Date'], format='%Y%m%d') df.set_index('Date', inplace=True) eoyPrice=df.resample('Y').last()[0:-1] # End of Decem- ber prices. Need to remove last date because it isn't really end of year annret=eoyPrice.pct_change().iloc[1:,:] # first row has NaN eojPrice=df.resample('BA-JAN').last()[1:-1] # End of January prices. Need to remove first date to match the years in lastdayofDec. Need to remove last date because it isn't really end of January. janret=(eojPrice.values-eoyPrice.values)/eoyPrice.values janret=janret[1:,] # match number of rows in annret for y in range(len(annret)): hasData=np.where(np.isfinite(annret.iloc[y, :]))[0] sortidx=np.argsort(annret.iloc[y, hasData]) topN=np.round(len(hasData)/10) portRet=(np.nanmean(janret[y, hasData[sortidx. iloc[np.arange(0, topN)]]])-np.nanmean(janret[y, hasData[sortidx.iloc[np.arange(-topN+1, -1)]]]))/2-2*onewaytcost # portfolio returns Chan800064_c07.indd 177 6/7/2021 7:16:58 AM 93 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. 178 QUANTITATIVE TRADING print(\"Last holding date %s: Portfolio return=%f\" % (eojPrice.index[y+1], portRet)) #Last holding date 2006-01-31 00:00:00: Portfolio return=-0.023853 #Last holding date 2007-01-31 00:00:00: Portfolio return=-0.003641 #Last holding date 2008-01-31 00:00:00: Portfolio return=0.088486 Using R The R codes can be found at epchan.com/book/example7_6.R, and the input data is also available there. # Need the lubridate package for its dates handling # install.packages('lubridate') library('lubridate') source('calculateReturns.R') source('fwdshift.R') onewaytcost <- 5/10000 # 5bps one way transaction cost data1 <- read.delim(\"IJR_20080131.txt\") # Tab-delimited cl <- data.matrix(data1[, 2:ncol(data1)]) tday <- ymd(data.matrix(data1[, 1])) # dates in lub- ridate format years <- year(tday) months <- month(tday) years <- as.matrix(years, length(years), 1) months <- as.matrix(months, length(months), 1) nextdayyear <- fwdshift(1, years) nextdaymonth <- fwdshift(1, months) eom <- which(months!=nextdaymonth) # End of month indices. eoy <- which(years!=nextdayyear) # End Of Year indices. Note that in R, 2008!=NaN returns FALSE whereas in Matlab 2008~=NaN returns TRUE annret <- calculateReturns(cl[eoy,], 1) # annual returns annret <- annret[-1,] monret <- calculateReturns(cl[eom,], 1) # monthly returns janret <- monret[months[eom]==1,] # January returns janret <- janret[-(1:2),] # First January does not have preceding year exitDay <- tday[months==1 & nextdaymonth==2] # Last day of Janurary exitDay <- exitDay[-(c(1))] # Exclude first January for (y in 1:nrow(annret)) { hasData <- which(is.finite(annret[y,])) # pick those stocks with valid annual returns Chan800064_c07.indd 178 6/7/2021 7:16:58 AM 94 This PDF file is part of the audiobook QUANTITATIVE TRADING and cannot be sold separately. It may not be reproduced, copied, circulated, or posted online. All rights reserved. Copyright \u00a9 Ernest P . Chan, 2021. Published by Echo Point Books & Media, LLC by arrangement with John Wiley & Sons, Inc. All Rights Reserved. Special Topics in Quantitative Trading 179 Does this seasonal stock strategy still work? I will leave it as an out-of-sample exercise for the reader. Another seasonal strategy in equities was proposed more recently (Heston and Sadka, 2007; available at lcb1.uoregon.edu/ rcg/seminars/seasonal072604.pdf). This strategy is very simple: each month, buy a number of stocks that performed the best in the same month a year earlier, and short the same number of stocks that performed poorest in that month a year earlier. The average annual return before 2002 was more than 13 percent before transac- tion costs. However, I have found that this effect has disappeared since then, as you can check for yourself in Example 7.7. (See the readers\u2019 comments to my blog post epchan.blogspot.com/2007/11/ seasonal-trades-in-stocks.html.) sortidx <- order(annret[y, hasData]) # sort stocks based on prior year's returns topN <- round(length(hasData)/10) # buy stocks with lowest decile of returns, and vice versa for highest decile portRet <- (sum(janret[y, hasData[sortidx[1:topN]]], na.rm=TRUE)- sum(janret[y, hasData[sortidx[(length(sortidx)- topN+1):length(sortidx)]]], na.rm=TRUE))/2/ topN-2*onewaytcost # portfolio returns msg <- sprintf('Last holding date %s: Portfolio return=%7.4f\\n', as.character(exitDay[y+1]), portRet) cat(msg) } # Last holding date 2006-01-31: Portfolio return=-0.0244 # Last holding date 2007-01-31: Portfolio return=-0.0068 # Last holding date 2008-01-31: Portfolio return= 0.0881 Example 7.7: Backtesting a Year-on-Year Seasonal Trending Strategy Here are the codes for the year-on-year seasonal trending strategy I quoted earlier. Note that the data contains survivorship bias, as it is based on the S&P 500 index on November 23, 2007. Chan800064_c07.indd 179 6/7/2021 7:16:59 AM Special Topics in Quantitative Trading 179 Does this seasonal stock strategy still work? I will leave it as an out-of-sample exercise for the reader. Another seasonal strategy in equities was proposed more recently (Heston and Sadka, 2007; available at lcb1.uoregon.edu/ rcg/seminars/seasonal072604.pdf). This strategy is very simple: each month, buy a number of stocks that performed the best in the same month a year earlier, and short the same number of stocks that performed poorest in that month a year earlier. The average annual return before 2002 was more than 13 percent before transac- tion costs. However, I have found that this effect has disappeared since then, as you can check for yourself in Example 7.7. (See the readers\u2019 comments to my blog post epchan.blogspot.com/2007/11/ seasonal-trades-in-stocks.html.) sortidx <- order(annret[y, hasData]) # sort stocks based on prior year's returns topN <- round(length(hasData)/10) # buy stocks with lowest decile of returns, and vice versa for highest decile portRet <- (sum(janret[y, hasData[sortidx[1:topN]]], na.rm=TRUE)- sum(janret[y, hasData[sortidx[(length(sortidx)- topN+1):length(sortidx)]]], na.rm=TRUE))/2/ topN-2*onewaytcost # portfolio returns msg <- sprintf('Last holding date %s:",
  "word_count": 1000,
  "topics": [
    "technical_analysis",
    "options",
    "psychology",
    "strategies"
  ],
  "created_at": "2026-02-05T00:37:43.610741"
}