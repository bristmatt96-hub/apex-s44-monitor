"""
Core Data Models for Trading System
"""
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any, List


class MarketType(Enum):
    """Types of markets we trade"""
    EQUITY = "equity"
    CRYPTO = "crypto"
    FOREX = "forex"
    OPTIONS = "options"
    SPAC = "spac"
    FUTURES = "futures"


class SignalType(Enum):
    """Types of trading signals"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class OrderType(Enum):
    """Order types"""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderStatus(Enum):
    """Order status"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    PARTIAL = "partial"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Signal:
    """A trading signal generated by analysis"""
    symbol: str
    market_type: MarketType
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    entry_price: float
    target_price: float
    stop_loss: float
    risk_reward_ratio: float
    source: str  # Which agent/strategy generated this
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def expected_gain_pct(self) -> float:
        """Expected percentage gain if target hit"""
        return ((self.target_price - self.entry_price) / self.entry_price) * 100

    @property
    def expected_loss_pct(self) -> float:
        """Expected percentage loss if stop hit"""
        return ((self.entry_price - self.stop_loss) / self.entry_price) * 100


@dataclass
class Opportunity:
    """A ranked trading opportunity"""
    signal: Signal
    score: float  # Composite score from ranker
    rank: int
    reasoning: List[str]
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class Trade:
    """A trade execution record"""
    id: str
    symbol: str
    market_type: MarketType
    side: str  # 'buy' or 'sell'
    quantity: float
    order_type: OrderType
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None
    status: OrderStatus = OrderStatus.PENDING
    fill_price: Optional[float] = None
    fill_quantity: Optional[float] = None
    commission: float = 0.0
    created_at: datetime = field(default_factory=datetime.now)
    filled_at: Optional[datetime] = None
    signal_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Position:
    """An open position"""
    symbol: str
    market_type: MarketType
    quantity: float
    entry_price: float
    current_price: float
    entry_time: datetime
    side: str = 'long'  # 'long' or 'short'
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0

    @property
    def pnl_pct(self) -> float:
        """Unrealized P&L percentage"""
        if self.side == 'short':
            return ((self.entry_price - self.current_price) / self.entry_price) * 100
        return ((self.current_price - self.entry_price) / self.entry_price) * 100

    @property
    def market_value(self) -> float:
        """Current market value"""
        return self.quantity * self.current_price


@dataclass
class MarketData:
    """Market data snapshot"""
    symbol: str
    market_type: MarketType
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    vwap: Optional[float] = None
    bid: Optional[float] = None
    ask: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class PortfolioSnapshot:
    """Portfolio state at a point in time"""
    timestamp: datetime
    cash: float
    positions: List[Position]
    total_value: float
    daily_pnl: float
    total_pnl: float
    day_trades_used: int = 0  # For PDT tracking
